
verschiedene mimetypen:

+        case PGM_IMAGE_RGB:
+          caps = gst_caps_new_simple
+            ("video/x-raw-rgb",
+             "bpp", G_TYPE_INT, 24, "depth", G_TYPE_INT, 24,
+             "red_mask",   G_TYPE_INT, 0x00ff0000,
+             "green_mask", G_TYPE_INT, 0x0000ff00,
+             "blue_mask",  G_TYPE_INT, 0x000000ff,
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+
+        case PGM_IMAGE_BGR:
+          caps = gst_caps_new_simple
+            ("video/x-raw-rgb",
+             "bpp", G_TYPE_INT, 24, "depth", G_TYPE_INT, 24,
+             "red_mask",   G_TYPE_INT, 0x000000ff,
+             "green_mask", G_TYPE_INT, 0x0000ff00,
+             "blue_mask",  G_TYPE_INT, 0x00ff0000,
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+
+        case PGM_IMAGE_RGBA:
+          caps = gst_caps_new_simple
+            ("video/x-raw-rgb",
+             "bpp", G_TYPE_INT, 32, "depth", G_TYPE_INT, 32,
+             "red_mask",   G_TYPE_INT, 0xff000000,
+             "green_mask", G_TYPE_INT, 0x00ff0000,
+             "blue_mask",  G_TYPE_INT, 0x0000ff00,
+             "alpha_mask", G_TYPE_INT, 0x000000ff,
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+
+        case PGM_IMAGE_BGRA:
+          caps = gst_caps_new_simple
+            ("video/x-raw-rgb",
+             "bpp", G_TYPE_INT, 32, "depth", G_TYPE_INT, 32,
+             "red_mask",   G_TYPE_INT, 0x0000ff00,
+             "green_mask", G_TYPE_INT, 0x00ff0000,
+             "blue_mask",  G_TYPE_INT, 0xff000000,
+             "alpha_mask", G_TYPE_INT, 0x000000ff,
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+
+        case PGM_IMAGE_I420:
+          caps = gst_caps_new_simple
+            ("video/x-raw-yuv",
+             "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('I', '4', '2', '0'),
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+
+        case PGM_IMAGE_YV12:
+          caps = gst_caps_new_simple
+            ("video/x-raw-yuv",
+             "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('Y', 'V', '1', '2'),
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+
+        case PGM_IMAGE_UYVY:
+          caps = gst_caps_new_simple
+            ("video/x-raw-yuv",
+             "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y'),
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+
+        case PGM_IMAGE_YUYV:
+          caps = gst_caps_new_simple
+            ("video/x-raw-yuv",
+             "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('Y', 'U', 'Y', 'V'),
+             "width",  GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "height", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+             "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1,
+             NULL);
+          break;
+







 TODO:
- FileReadQT4l funktioniert noch nicht richtig
- Exceptions in dynamic libraries


Georg schreiben




Hannes schreiben:
<<<<<<< TODO



CVS:
- auschecken mit cvs -z9 -d:ext:holzi1@cvs.gem.iem.at:/cvsroot/pd-gem co -r videoIO Gem
- Teile auscheckehn cvs update
- einchecken: immer cvs commit -r videoIO *.h TODO (alle Datein angeben)
- beim ersten mal adden: cvs add *.h
    
    
    
Fragen:
- Error handling?? >>>>> Exception exits???
- link vom Design pattern (OK)
- wegen YUV Formate fragen (OK)


PLUGIN-FACTORY:
	(read+write)
	factory.getPlugin() needs argument, to decide which plugin to use
		arguments include: 	"filename" (connection string)
					"colorspace"
					"preferred_plugin" (esp. important when writing; but might also be of interested when reading)
					...
		use argument map (id<->value);
		

	think about PRIORITIES: several plugins can decode the same "file", but some might do a better job; these should be used!
				therefore a plugin returns a value on "how good" it is at decoding the specified thing
						a return value of "-1" would mean: i CANNOT do this


colorspaces:
	request at plugin-instantiation a certain colorspace in FourCC code (string? hex-value?)
	for now we do not offer any automatic converision:
		either the decoding-libraries offer the requested format, or we get some "native" format
	if we don't care, set the FourCC to <null>

	what about "writing"?  conversion in the host (if plugin does not know how to handle the requested cs)


error checking:
	exceptions


// on parameter maps
class VIOPluginParameter {
	/* this is bad as it needs re-compilation of plugins and hosts! */
	setFilename(String s);
	setColorspace(int);

	/* this is good, as neither plugins nor hosts need to be recompiled */
	setParameter(String id, String parm); // id=="filename" or id="colorspace";
	setParameter(String id, int parm);

	Map<>map;

	getParameter();

}

setParameter("mysuperaparm", huhu);
>>>>>>> 1.1.2.2
